// Note: This file was auto-generated by SocketStream at 1363900905533
// Do not modify!

module.exports = function(app) {

  // PASS THROUGH CONFIG
  app.env = 'development';

  // DEFINE TRANSPORT
  app.transport(function (options) {

  options.protocol = options.protocol || 'ws';
  options.host = options.host || 'localhost';

  var parser = require('ss-message-parser')();

  // Connect
  return function (client) {
   
    var socket = new eio(options.protocol + '://' + options.host + ':' + options.port);

    socket.on('open', function(){
      return client.status.emit('open');
    });

    socket.on('ready', function() {
      return client.status.emit('ready');
    });

    socket.on('disconnect', function() {
      return client.status.emit('disconnect');
    });

    socket.on('reconnect', function() {
      return client.status.emit('reconnect');
    });

    socket.on('connect', function() {
      return client.status.emit('connect');
    });

    socket.on('message', function(msg) {
      var msgAry = parser.parse(msg);
      client.services.processIncomingMessage(msgAry[0], msgAry[1]);
    });

    // Return API
    return {

      write: function(serviceId, content) {
        var msg = parser.serialize([serviceId, content]);
        socket.send(msg);
      }

    };

  }

}, {"port":3001});

  // DEFINE SERVICES

  // livereload service
  app.services.register({"id":0,"name":"livereload","use":{}}, function (client) {

  client.onmessage = function(msg) {

    // Reload browser if reload system event received
    switch (msg) {
      case 'reload':
        window.location.reload();
        break;
      case 'updateCSS':
        var tags = document.getElementsByTagName("link");
        for (var i = 0; i < tags.length; i++) {
          var tag = tags[i];
          if (tag.rel.toLowerCase().indexOf("stylesheet") >= 0 && tag.href) {
            var h = tag.href.replace(/(&|%5C?)\d+/, "");
            tag.href = h + (h.indexOf("?") >= 0 ? "&" : "?") + (new Date().valueOf());
          }
        }
        break;
    }
  };

});

  // pubsub service
  app.services.register({"id":1,"name":"pubsub","use":{"json":true}}, function (client) {

  var EE = require('events').EventEmitter;
  var ee = new EE();

  client.onmessage = function(obj) {
    ee.emit(obj.e, obj.p);
  };

  return ee;

});

  // rpc service
  app.services.register({"id":2,"name":"rpc","use":{"json":true,"callbacks":true}}, function (client) {

  function defaultCallback(x) {
    return console.log(x);
  }

  // Return API to call functions on the server
  return function() {
    var args = Array.prototype.slice.call(arguments);

    var msg = { m: args[0] };
    var lastArg = args[args.length - 1];

    var cb;
    if (typeof lastArg === 'function') {
      msg.p = args.slice(1, args.length - 1);
      cb = lastArg;
    } else {
      msg.p = args.slice(1);
      cb = defaultCallback;
    }

    client.send(msg, function(obj){
      if (obj.e) {
        console.error('RPC server error:', obj.e.message);
      } else {
        cb.apply(cb, obj.p);
      }
    });

    // Always return 'undefined'      
    return void 0;
  };

});

  // tweetStream service
  app.services.register({"id":3,"name":"tweetStream","use":{}}, function (client) {

  var Stream = require('stream');

  // Only Streams1 in Browserify for now :-(
  var s = new Stream();

  s.readable = true;
  s.writable = true;

  client.onmessage = function(msg) {
    console.log('message in from stream service!', msg);
    s.emit('data', msg);
  };

  s.write = function(buf) {
    client.write(buf);
  };

  return s;

});

  // square service
  app.services.register({"id":4,"name":"square","use":{"callbacks":true}}, function (client){

      // invoke this function with ss.square() on the client
      return function(question) {
        client.send(question, function(answer){
          alert(answer);
        });
      };

    });

  return app;
};
